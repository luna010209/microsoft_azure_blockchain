export type JsonCompatible<T> = any;
export interface DataConverter<T> {
    encode(val: T): ArrayBuffer;
    decode(arr: ArrayBuffer): T;
}
export type TypedArray = ArrayBufferView;
export interface TypedArrayConstructor<T extends TypedArray> {
    new (buffer: ArrayBuffer, byteOffset?: number, length?: number): T;
}
/**
 * Converter for `boolean` values.
 *
 * A `boolean` is represented as `uint8` where `true` is `1`
 * and `false` is `0`.
 *
 * Example:
 * ```
 * const buf = ccfapp.bool.encode(true); // ArrayBuffer of size 1
 * const val = ccfapp.bool.decode(buf);  // boolean
 * ```
 */
export declare const bool: DataConverter<boolean>;
/**
 * Converter for `number` values, encoded as `int8`.
 *
 * Example:
 * ```
 * const buf = ccfapp.int8.encode(-50); // ArrayBuffer of size 1
 * const val = ccfapp.int8.decode(buf); // number
 * ```
 */
export declare const int8: DataConverter<number>;
/**
 * Converter for `number` values, encoded as `uint8`.
 *
 * Example:
 * ```
 * const buf = ccfapp.uint8.encode(255); // ArrayBuffer of size 1
 * const val = ccfapp.uint8.decode(buf); // number
 * ```
 */
export declare const uint8: DataConverter<number>;
/**
 * Converter for `number` values, encoded as `int16`.
 *
 * Example:
 * ```
 * const buf = ccfapp.int16.encode(-1000); // ArrayBuffer of size 2
 * const val = ccfapp.int16.decode(buf);   // number
 * ```
 */
export declare const int16: DataConverter<number>;
/**
 * Converter for `number` values, encoded as `uint16`.
 *
 * Example:
 * ```
 * const buf = ccfapp.uint16.encode(50000); // ArrayBuffer of size 2
 * const val = ccfapp.uint16.decode(buf);   // number
 * ```
 */
export declare const uint16: DataConverter<number>;
/**
 * Converter for `number` values, encoded as `int32`.
 *
 * Example:
 * ```
 * const buf = ccfapp.int32.encode(-50000); // ArrayBuffer of size 4
 * const val = ccfapp.int32.decode(buf);    // number
 * ```
 */
export declare const int32: DataConverter<number>;
/**
 * Converter for `number` values, encoded as `uint32`.
 *
 * Example:
 * ```
 * const buf = ccfapp.uint32.encode(50000); // ArrayBuffer of size 4
 * const val = ccfapp.uint32.decode(buf);   // number
 * ```
 */
export declare const uint32: DataConverter<number>;
/**
 * Converter for `bigint` values, encoded as `int64`.
 *
 * Example:
 * ```
 * const n = 2n ** 53n + 1n; // larger than Number.MAX_SAFE_INTEGER
 * const buf = ccfapp.int64.encode(n);   // ArrayBuffer of size 8
 * const val = ccfapp.int64.decode(buf); // bigint
 * ```
 */
export declare const int64: DataConverter<bigint>;
/**
 * Converter for `bigint` values, encoded as `uint64`.
 *
 * Example:
 * ```
 * const n = 2n ** 53n + 1n; // larger than Number.MAX_SAFE_INTEGER
 * const buf = ccfapp.uint64.encode(n);   // ArrayBuffer of size 8
 * const val = ccfapp.uint64.decode(buf); // bigint
 * ```
 */
export declare const uint64: DataConverter<bigint>;
/**
 * Converter for `number` values, encoded as `float32`.
 *
 * Example:
 * ```
 * const buf = ccfapp.float32.encode(3.141); // ArrayBuffer of size 4
 * const val = ccfapp.float32.decode(buf);   // number
 * ```
 */
export declare const float32: DataConverter<number>;
/**
 * Converter for `number` values, encoded as `float64`.
 *
 * Example:
 * ```
 * const buf = ccfapp.float64.encode(3.141); // ArrayBuffer of size 8
 * const val = ccfapp.float64.decode(buf);   // number
 * ```
 */
export declare const float64: DataConverter<number>;
/**
 * Converter for `string` values, encoded as UTF-8.
 *
 * Example:
 * ```
 * const buf = ccfapp.string.encode('my-string'); // ArrayBuffer
 * const val = ccfapp.string.decode(buf);         // string
 * ```
 */
export declare const string: DataConverter<string>;
/**
 * Returns a converter for JSON-compatible objects or values.
 *
 * {@linkcode DataConverter.encode | encode} first serializes the object
 * or value to JSON and then converts the resulting string to an `ArrayBuffer`.
 * JSON serialization uses `JSON.stringify()` without `replacer` or
 * `space` parameters.
 *
 * {@linkcode DataConverter.decode | decode} converts the `ArrayBuffer`
 * to a string and parses it using `JSON.parse()` without `reviver`
 * parameter.
 *
 * Example:
 * ```
 * interface Person {
 *   name: string
 *   age: number
 * }
 * const person: Person = { name: "John", age: 42 };
 * const conv = ccfapp.json<Person>();
 * const buffer = conv.encode(person); // ArrayBuffer
 * const person2 = conv.decode(buffer); // Person
 * ```
 */
export declare const json: <T extends JsonCompatible<T>>() => DataConverter<T>;
/**
 * Returns a converter for JSON-compatible objects or values, with errors for
 * known-incompatible types.
 *
 * Based on {@linkcode json}, but additionally runs a check during every encode
 * call, throwing an error if the object contains fields which cannot be round-tripped
 * to JSON (Date, Map). This incurs some cost in checking each instance, but gives
 * clear errors rather than late serdes mismatches.
 *
 * Example:
 * ```
 * interface Data {
 *   m: Map<string, string>
 * }
 * const d: Data = { m: new Map<string, string>() };
 * d.m.set("hello", "John");
 *
 * const conv = ccfapp.json<Data>();
 * const buffer = conv.encode(d); // ArrayBuffer, but contents of map silently lost!
 * const d2 = conv.decode(buffer); // Data, but doesn't match d!
 *
 * const convChecked = ccfapp.checkedJson<Data>();
 * const buffer2 = convChecked.encode(d); // Throws TypeError
 * ```
 */
export declare const checkedJson: <T extends JsonCompatible<T>>() => DataConverter<T>;
/**
 * Returns a converter for [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) objects.
 *
 * Note that a `TypedArray` is a view into an underlying `ArrayBuffer`.
 * This view allows to cover a subset of the `ArrayBuffer`, for example
 * when using `TypedArray.prototype.subarray()`.
 * For views which are subsets, a roundtrip from `TypedArray` to `ArrayBuffer`
 * and back will yield a `TypedArray` that is not a subset anymore.
 *
 * Example:
 * ```
 * const arr = new Uint8Array([42]);
 * const conv = ccfapp.typedArray(Uint8Array);
 * const buffer = conv.encode(arr); // ArrayBuffer of size arr.byteLength
 * const arr2 = conv.decode(buffer); // Uint8Array
 * ```
 *
 * @param clazz The TypedArray class, for example `Uint8Array`.
 */
export declare const typedArray: <T extends TypedArray>(clazz: TypedArrayConstructor<T>) => DataConverter<T>;
/**
 * Identity converter.
 * {@linkcode DataConverter.encode | encode} / {@linkcode DataConverter.decode | decode}
 * return the input `ArrayBuffer` unchanged. No copy is made.
 *
 * This converter can be used with {@linkcode kv.typedKv} when the key or value
 * type is `ArrayBuffer`, in which case no conversion is applied.
 */
export declare const arrayBuffer: DataConverter<ArrayBuffer>;
